15-418/618 Spring 2017
Recitation Notes Week 11
14 Apr 2017

This recitation focuses on fine-grained locking, using the binary
search tree example of Exercise 5, with some modifications.

Code is available as:
    /afs/cs.cmu.edu/academic/class/15418-s17/recitations/recw11.tar

DATA STRUCTURES

// Wrapper around pthread mutex,
// but it also injects random delays
// into locking & unlocking 
struct Lock {
 public:
    pthread_mutex_t mutex;
    Lock();  // Constructor initializes the lock
    void lock();
    void unlock();
};

// Nodes in BST
struct Node {
 public:
    Node *left, *right;
    Lock lock;
    int value;

    Node(int value);
};

// BST representation
class BST {
 public:
    mode_t mode;              // What synchronization mechanisms to use
    int count;                // How many elements are in the tree
    
    BST(mode_t mode);         // Create empty BST
    bool insert(int val);     // Insert value into BST
    bool remove(int val);     // Remove a value from BST
    int sum();                // Compute the sum of the elements
    void print(bool show_tree); // Print the members

 private:              // Representation
    Lock glock;        // Protect global data
    // Have dummy node, such that true root is its left child
    Node *pseudoroot;

    ...
}

Note the use of a "pseudo root."  This is a clean way to handle cases
where the root is null or must be modified.  The real root is at
pseudoroot->left.

INSERTION (SEQUENTIAL)

// Insert value into BST.  Return false if it's already there
// Sequential code
bool BST::insert_basic(int val) {
    // Strategy: Find position at which to insert node
    Node **nloc = &pseudoroot->left;  // Possible insertion address
    Node *node = *nloc;               // Current node
    bool found = false;
    while (node != NULL) {
	if (val == node->value) {
	    // Already in tree
	    found = true;
	    break;
	} else {
	    // Walk down tree to find insertion point
	    if (val <= node->value)
		nloc = &node->left;
	    else 
		nloc = &node->right;
	    node = *nloc;
	}
    }
    if (!found) {
	// Create and insert new node
	*nloc = new Node(val);
	count++;
    }
    return !found;
}

Exercises:
1. Build BST by inserting values 3, 1, 5, 4, 9, 2, 6 into empty tree

Questions:
1. How does this code handle insertion into an empty tree?
2. How does it detect when the value is already in the tree?
3. What transformations can occur to the tree as more values are inserted?

INSERTION (SIMPLE CONCURRENT)

Modify the given code so that it can handle multiple insertions
concurrently.  You may find the code from Exercise 5 to be useful.
Use hand-over-hand locking

// Insert value into BST.  Return false if it's already there
// Locking good enough to allow multiple insertions concurrently 
bool BST::insert_simple_synch(int val) {
    pseudoroot->lock.lock();

    // Your code here
    Node *prev = psedoroot;
    Node **nloc = &pseudoroot->left; // Insertion position within parent
    Node *node = *nloc;              // Node being examined
    while (node != NULL) {

    // Your code here
    node->lock.lock()
    prev->lock.unlock();
	if (val == node->value) {
	    // Already in tree
        
    // Your code here
        node->lock.unlock();
	    return false;
	} else {
        prev = node;
    // Your code here

	    if (val <= node->value)
		nloc = &node->left;
	    else 
		nloc = &node->right;
	    node = *nloc;
	}
    }
    *nloc = new Node(val);

    // Your code here
    prev->lock.unlock();

    glock.lock();
    count++;
    glock.unlock();
    return true;
}

Questions
1. Why start by locking pseudoroot?
2. What is the role of glock?
3. At what point should node be locked?
4. How can we be sure to unlock node's parent?
5. When can we unlock node's parent?
6. Is hand-over-hand locking required to support concurrent insertions?

SUMMING TREE (SIMPLE CONCURRENT)

// Here's sequential code to sum the elements of the tree.
// It's called at the top level with n = root
int BST::sum_subtree_basic(Node *n) {
    if (n == NULL)
	return 0;
    return n->value
	+ sum_subtree_basic(n->left)
	+ sum_subtree_basic(n->right);
}

Write a version that's good enough to run when new nodes are being
inserted, and it will get the correct result, even if other insertion
operations precede or follow this one.  

// Synchronization good enough to be concurrent with insertions
int BST::sum_subtree_simple_synch(Node *node) {
    // If node nonnull, then it is locked
    // and should be released by this function
    if (node == NULL)
	return 0;

    Node *left = node->left;
    Node *right = node->right;

    // Your code here
    if (left) left->lock.lock();
    if (right) right->lock.lock();
    node->lock.unlock();


    int val = node->value; // we do not need lock it, because insert will not change its value
    val += sum_subtree_simple_synch(left);
    val += sum_subtree_simple_synch(right);

    return val;
}
{
    pseudoroot->lock.lock();
    root = pseudoroot->left;
    if (root)
        root->lock.lock();
    pseudoroot->lock.unlock();
    sum_subtree_simple_synch(root); // cannot be pseudoroot->left, it can be NULL
}


Questions:

1. How should this code be called at the top level to ensure that it
   can't jump ahead of earlier insertion operations?
   a. Does your solution work when the tree is empty?
2. Why was hand-over-hand locking by the insertion operation necessary?
3. Is possible for node->left to differ from left when the first
   recursive call is made?  What is the implication of this?
4. Is possible for node->right to differ from right when the second
   recursive call is made?  What is the implication of this?

DELETION (SEQUENTIAL)

Deleting from a BST is tricky.  Here's the sequential code
// Remove value from BST
// Return false if value not present
// Removal can require restructuring of tree
bool BST::remove_basic(int val) {
    // Want to find position in tree currently holding val
    Node **nloc = &pseudoroot->left;  // Location in parent
    Node *node = *nloc;               // of node being examined
    // Traverse tree to find node
    while (node != NULL && node->value != val) {
	if (val <= node->value)
	    nloc = &node->left;
	else
	    nloc = &node->right;
	node = *nloc;
    }
    if (node == NULL)
	// Value not in tree
	return false;
    // Value to be deleted is in node
    if (node->left == NULL || node->right == NULL) {
	// Easy case: one of node's subtrees is empty
	// Can replace node by the subtree
	*nloc = node->left ? node->left : node->right;
	// Free node that formerly held val
	delete node;
    } else {
	// Node has two subtrees
	// Locate minimum element in right subtree
	Node **mloc = &node->right; // Location in parent
	Node *mnode = *mloc;        // of possible minimum element
	while (mnode->left != NULL) {
	    mloc = &(mnode->left);
	    mnode = *mloc;
	}
	// mnode value becomes new value for element
	node->value = mnode->value;
	// replace pointer to mnode in parent with mnode's right subtree
	*mloc = mnode->right;
	// Free node that formerly held minimum value
	delete mnode;
    }
    count--;
    return true;
}

Exercise:
1. Insert value 4.5 into earlier example tree
2. Delete value 9 from earlier example tree
3. Delete value 1 from earlier example tree
4. Delete value 3 from earlier example tree


Questions
1. How would the code handle deletion from an empty tree?
2. How would the code handle deleting the only element in a tree?
3. What structural modifications can the code make to the tree?
4. Why is it safe to move the minimum value in the right subtree into
   the deletion point?
5. What's a simple way to find the minimum element in a subtree?
6. Can the node holding the minimum value in a subtree have a left child?
7. Would it be possible to remove an element from the left subtree?
   Which one?

DELETION (CONCURRENT) HARD!

Here's working code

// Remove value from BST
// Return false if value not present
// Removal can require restructuring of tree
// Support locking that can run concurrently with inserts and deletes
bool BST::remove_full_synch(int val) {
    pseudoroot->lock.lock();
    Node *parent = pseudoroot;
    Node **nloc = &pseudoroot->left;
    Node *node = *nloc;
    if (node) 
	node->lock.lock();

    while (node != NULL && node->value != val) {
	// Hand-over-hand locking, but maintain 2 levels of locks
	// One on node, and one on its parent
	if (val <= node->value) {
	    nloc = &node->left;
	} else {
	    nloc = &node->right;
	}
	parent->lock.unlock();
	parent = node;
	node = *nloc;
	if (node) 
	    node->lock.lock();
    }
    if (node == NULL) {
	// Value not in tree.  Only need to release parent lock
	parent->lock.unlock();
	return false;
    }
    // Value to be deleted is in node node
    // nloc points to location in tree holding pointer to node
    // Have lock of node and its parent
    if (node->left == NULL || node->right == NULL) {
	// One of node's subtrees is empty
	// Replace pointer to node by pointer to other subtree
	*nloc = node->left  ? node->left : node->right;
	parent->lock.unlock();
	// Don't really need to do this, but it's a good habit
	node->lock.unlock();
	delete node;
    } else {
	// Node has two subtrees.  Must find node with minimum
	// value in right subtree.  
	// Can remove lock on parent, but keep lock on node
	parent->lock.unlock();
	// Keep two levels locked
	parent = NULL;  // Real parent is node, but it should stay locked
	Node **mloc = &node->right;
	Node *mnode = *mloc;
	mnode->lock.lock();
	while (mnode->left != NULL) {
	    // Hand-over-hand locking as find node with minimum value
	    if (parent)
		parent->lock.unlock();
	    parent = mnode;
	    mloc = &(mnode->left);
	    mnode = *mloc;
	    mnode->lock.lock();
	}
	node->value = mnode->value;
	*mloc = mnode->right;
	if (parent)
	    parent->lock.unlock();
	node->lock.unlock();
	// Don't really need to do this, but it's a good habit
	mnode->lock.unlock();
	delete mnode;
    }
    glock.lock();
    count--;
    glock.unlock();
    return true;
}

Questions
1. Why does it need to keep two nodes locked along a path?
2. What is the maximum number of nodes that can be locked at any given time?
3. Will the locks be for contiguous nodes?
4. What will happen if there are earlier insertion operations taking place?
   Can it lock nodes in the gap formed by this opearation?   
5. What will happen if there are earlier deletion operations taking place?
   Can it lock nodes in the gap formed by this opearation?   
6. When looking for the minimum element in the right subtree, why can
   the parent of node be unlocked?
7. Can a later operation overtake this one?
8. What will happen if the earlier summation code is run with this?

SUMMATION (CONCURRENT)

Here's a version of the summation code that is compatible with deletion

int BST::sum_subtree_full_synch(Node *node, Node *parent) {
    // If parent nonnull, then it is locked and should be released
    if (node == NULL) {
	if (parent)
	    parent->lock.unlock();
	return 0;
    }
    node->lock.lock();
    if (parent)
	parent->lock.unlock();
    int val = node->value;
    val += sum_subtree_full_synch(node->left, NULL);
    // Can release lock on this node once start summing right subtree
    val += sum_subtree_full_synch(node->right, node);
    return val;
}

Questions
1. What should the top-level call be to this function?
2. When is the lock on node released?
3. Why does it need to be held this long?
4. Why can this code run concurrently with deletion operations?
5. How much longer do nodes stay locked than with the other summation
   code?

IMPORTANT LESSONS

1. Concurrent mechanisms depend greatly on set of operations to be
   supported.
   a. Adding summation complicates insertion
   b. Adding deletion complicates summation

2. Best to refine sequential code.  Especially to reduce number of
   special cases
   a. Use of pseudoroot
   b. Tracking of location for updating pointer

3. Need good testing framework
   a. Stresses many different interleavings
   b. Lots of random data and operations
   c. Provided code is not full testing harness:
      * Does not guarantee serialization of top-level operations
      * Does not check results
